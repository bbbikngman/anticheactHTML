<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ğŸ¤– WebRTCåè¯ˆAIåŒå·¥å¯¹è¯å®¢æˆ·ç«¯</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #333;
      }

      .container {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        max-width: 800px;
        width: 90%;
        backdrop-filter: blur(10px);
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        color: #4a5568;
        margin-bottom: 10px;
        font-size: 2.2em;
      }

      .header p {
        color: #718096;
        font-size: 1.1em;
      }

      .status-card {
        background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        border: 1px solid #e2e8f0;
      }

      .connection-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-bottom: 20px;
        font-size: 0.9em;
      }

      .connection-info div {
        padding: 10px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 8px;
        border: 1px solid #e2e8f0;
      }

      .connection-info strong {
        color: #2d3748;
        display: block;
        margin-bottom: 5px;
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .status-item {
        text-align: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        border: 1px solid #e2e8f0;
      }

      .status-label {
        font-size: 0.85em;
        color: #718096;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .status-value {
        font-size: 1.1em;
        font-weight: bold;
        color: #2d3748;
      }

      .status-value.success {
        color: #38a169;
      }

      .status-value.warning {
        color: #d69e2e;
      }

      .status-value.error {
        color: #e53e3e;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 25px;
        font-size: 1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 120px;
        position: relative;
        overflow: hidden;
      }

      .btn:before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .btn:hover:before {
        left: 100%;
      }

      .btn-primary {
        background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
      }

      .btn-secondary {
        background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
      }

      .btn-secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(237, 137, 54, 0.4);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
      }

      .audio-visualizer {
        background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        text-align: center;
      }

      .audio-visualizer h3 {
        color: #e2e8f0;
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      #audioCanvas {
        width: 100%;
        height: 120px;
        border-radius: 10px;
        background: #000;
        margin-bottom: 10px;
      }

      .audio-level {
        color: #4299e1;
        font-size: 1.2em;
        font-weight: bold;
      }

      .log-container {
        background: #1a202c;
        border-radius: 15px;
        padding: 20px;
        max-height: 300px;
        overflow-y: auto;
      }

      .log-container h3 {
        color: #e2e8f0;
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 8px 12px;
        border-radius: 6px;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 0.85em;
        line-height: 1.4;
      }

      .log-entry.info {
        background: rgba(66, 153, 225, 0.1);
        color: #90cdf4;
        border-left: 3px solid #4299e1;
      }

      .log-entry.success {
        background: rgba(56, 161, 105, 0.1);
        color: #9ae6b4;
        border-left: 3px solid #38a169;
      }

      .log-entry.warning {
        background: rgba(214, 158, 46, 0.1);
        color: #faf089;
        border-left: 3px solid #d69e2e;
      }

      .log-entry.error {
        background: rgba(229, 62, 62, 0.1);
        color: #feb2b2;
        border-left: 3px solid #e53e3e;
      }

      .timestamp {
        opacity: 0.7;
        font-size: 0.8em;
      }

      /* å“åº”å¼è®¾è®¡ */
      @media (max-width: 768px) {
        .container {
          padding: 20px;
          margin: 10px;
        }

        .connection-info {
          grid-template-columns: 1fr;
        }

        .status-grid {
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        .btn {
          width: 100%;
          max-width: 250px;
        }
      }

      /* åŠ¨ç”»æ•ˆæœ */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .recording {
        animation: pulse 1.5s infinite;
      }

      /* æ»šåŠ¨æ¡æ ·å¼ */
      .log-container::-webkit-scrollbar {
        width: 6px;
      }

      .log-container::-webkit-scrollbar-track {
        background: #2d3748;
        border-radius: 3px;
      }

      .log-container::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 3px;
      }

      .log-container::-webkit-scrollbar-thumb:hover {
        background: #718096;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ¤– åè¯ˆAIåŒå·¥å¯¹è¯ç³»ç»Ÿ</h1>
        <p>åŸºäºWebRTCçš„å®æ—¶è¯­éŸ³äº¤äº’å¹³å°</p>
      </div>

      <div class="status-card">
        <div class="connection-info">
          <div>
            <strong>WebRTCæœåŠ¡:</strong>
            <span id="webrtcAddress">http://81.71.152.21:8080</span>
          </div>
          <div>
            <strong>WebSocket:</strong>
            <span id="wsAddress">ws://81.71.152.21:31004</span>
          </div>
          <div>
            <strong>è¿æ¥çŠ¶æ€:</strong> <span id="connectionStatus">æœªè¿æ¥</span>
          </div>
          <div>
            <strong>ç³»ç»ŸçŠ¶æ€:</strong> <span id="systemStatus">å¾…æœºä¸­</span>
          </div>
        </div>

        <div class="status-grid">
          <div class="status-item">
            <div class="status-label">WebRTCçŠ¶æ€</div>
            <div class="status-value" id="webrtcStatus">æœªè¿æ¥</div>
          </div>
          <div class="status-item">
            <div class="status-label">éŸ³é¢‘çŠ¶æ€</div>
            <div class="status-value" id="audioStatus">æœªæ¿€æ´»</div>
          </div>
          <div class="status-item">
            <div class="status-label">AIçŠ¶æ€</div>
            <div class="status-value" id="aiStatus">å¾…æœº</div>
          </div>
          <div class="status-item">
            <div class="status-label">å»¶è¿Ÿ</div>
            <div class="status-value" id="latency">-- ms</div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn btn-primary" id="connectBtn">ğŸ”— è¿æ¥æœåŠ¡å™¨</button>
        <button class="btn btn-secondary" id="disconnectBtn" disabled>
          ğŸ”Œ æ–­å¼€è¿æ¥
        </button>
      </div>

      <div class="audio-visualizer">
        <h3>ğŸµ éŸ³é¢‘å¯è§†åŒ–</h3>
        <canvas id="audioCanvas"></canvas>
        <div class="audio-level">
          éŸ³é¢‘ç”µå¹³: <span id="audioLevel">0%</span>
        </div>
      </div>

      <div class="log-container">
        <h3>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
        <div id="logOutput"></div>
      </div>
    </div>

    <script>
      // å…¨å±€å˜é‡
      let pc = null;
      let localStream = null;
      let remoteStream = null;
      let websocket = null;
      let audioContext = null;
      let analyser = null;
      let dataArray = null;
      let animationId = null;

      // æœåŠ¡å™¨é…ç½®
      const SERVER_URL = "http://81.71.152.21:8080";
      const WS_URL = "ws://81.71.152.21:31004";

      // DOMå…ƒç´ 
      const elements = {
        connectBtn: document.getElementById("connectBtn"),
        disconnectBtn: document.getElementById("disconnectBtn"),
        webrtcStatus: document.getElementById("webrtcStatus"),
        audioStatus: document.getElementById("audioStatus"),
        aiStatus: document.getElementById("aiStatus"),
        latency: document.getElementById("latency"),
        connectionStatus: document.getElementById("connectionStatus"),
        systemStatus: document.getElementById("systemStatus"),
        logOutput: document.getElementById("logOutput"),
        audioCanvas: document.getElementById("audioCanvas"),
        audioLevel: document.getElementById("audioLevel"),
      };

      // ç»Ÿè®¡æ•°æ®
      const stats = {
        startTime: null,
        messagesReceived: 0,
        messagesSent: 0,
        errors: 0,
      };

      // äº‹ä»¶ç›‘å¬å™¨
      elements.connectBtn.addEventListener("click", connectToServer);
      elements.disconnectBtn.addEventListener("click", disconnectFromServer);

      // æ—¥å¿—å‡½æ•°
      function log(message, type = "info") {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry ${type}`;
        logEntry.innerHTML = `
          <span class="timestamp">[${timestamp}]</span> ${message}
        `;
        elements.logOutput.appendChild(logEntry);
        elements.logOutput.scrollTop = elements.logOutput.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      // åˆå§‹åŒ–WebSocketè¿æ¥
      async function initWebSocket() {
        try {
          websocket = new WebSocket(WS_URL);

          websocket.onopen = () => {
            log("WebSocketè¿æ¥å·²å»ºç«‹");
            elements.connectionStatus.textContent = "WebSocketå·²è¿æ¥";

            // å‘é€ç»‘å®šæ¶ˆæ¯
            const bindMsg = {
              type: "bind",
              client_id: "web_client_" + Date.now(),
              timestamp: Date.now(),
            };
            websocket.send(JSON.stringify(bindMsg));
            log("å·²å‘é€WebSocketç»‘å®šæ¶ˆæ¯");
          };

          websocket.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              handleWebSocketMessage(message);
            } catch (e) {
              log("WebSocketæ¶ˆæ¯è§£æå¤±è´¥: " + e.message, "error");
            }
          };

          websocket.onclose = () => {
            log("WebSocketè¿æ¥å·²å…³é—­");
            elements.connectionStatus.textContent = "WebSocketå·²æ–­å¼€";
          };

          websocket.onerror = (error) => {
            log("WebSocketé”™è¯¯: " + error.message, "error");
          };
        } catch (error) {
          log("WebSocketåˆå§‹åŒ–å¤±è´¥: " + error.message, "error");
        }
      }

      // å¤„ç†WebSocketæ¶ˆæ¯
      function handleWebSocketMessage(message) {
        log("æ”¶åˆ°WebSocketæ¶ˆæ¯: " + message.type);
        stats.messagesReceived++;

        switch (message.type) {
          case "bind_confirm":
            log("WebSocketç»‘å®šç¡®è®¤", "success");
            break;
          case "interrupt_signal":
            log("æ”¶åˆ°æ‰“æ–­ä¿¡å·", "warning");
            break;
          // æ³¨æ„ï¼šAIéŸ³é¢‘å›å¤ç°åœ¨é€šè¿‡WebRTCè½¨é“ä¼ è¾“ï¼Œä¸å†éœ€è¦WebSocketå¤„ç†
        }
      }

      // è¿æ¥åˆ°æœåŠ¡å™¨
      async function connectToServer() {
        try {
          log("å¼€å§‹è¿æ¥åˆ°æœåŠ¡å™¨...");
          elements.connectBtn.disabled = true;
          elements.systemStatus.textContent = "è¿æ¥ä¸­...";

          // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("æµè§ˆå™¨ä¸æ”¯æŒWebRTC");
          }

          // åˆå§‹åŒ–WebSocket
          await initWebSocket();

          // è·å–ç”¨æˆ·åª’ä½“
          log("è¯·æ±‚éº¦å…‹é£æƒé™...");
          localStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 16000,
            },
            video: false,
          });

          log("âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸ");
          elements.audioStatus.textContent = "å·²æ¿€æ´»";
          elements.audioStatus.className = "status-value success";

          // åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–
          initAudioVisualization();

          // åˆ›å»ºPeerConnection
          log("ğŸ”— åˆ›å»ºPeerConnection...");
          pc = new RTCPeerConnection({
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
            ],
          });

          // æ·»åŠ æœ¬åœ°æµ
          localStream.getTracks().forEach((track) => {
            pc.addTrack(track, localStream);
          });

          // å¤„ç†è¿œç¨‹æµ
          pc.ontrack = (event) => {
            log("ğŸ”Š æ”¶åˆ°è¿œç¨‹éŸ³é¢‘æµ");
            remoteStream = event.streams[0];
            const audio = new Audio();
            audio.srcObject = remoteStream;
            audio.autoplay = true;
            log("âœ… è¿œç¨‹éŸ³é¢‘å¼€å§‹æ’­æ”¾");
          };

          // ICEè¿æ¥çŠ¶æ€å˜åŒ–
          pc.oniceconnectionstatechange = () => {
            elements.webrtcStatus.textContent = pc.iceConnectionState;
            log(`ğŸ”— WebRTCçŠ¶æ€: ${pc.iceConnectionState}`);
            if (pc.iceConnectionState === "connected") {
              elements.webrtcStatus.className = "status-value success";
              elements.systemStatus.textContent = "å·²è¿æ¥";
              elements.disconnectBtn.disabled = false;
              log("ğŸ‰ WebRTCè¿æ¥å»ºç«‹æˆåŠŸï¼", "success");
              stats.startTime = Date.now();
            } else if (pc.iceConnectionState === "failed") {
              elements.webrtcStatus.className = "status-value error";
              log("âŒ WebRTCè¿æ¥å¤±è´¥", "error");
              stats.errors++;
            }
          };

          // åˆ›å»ºoffer
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // å‘é€offeråˆ°æœåŠ¡å™¨
          const response = await fetch(`${SERVER_URL}/offer`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              sdp: offer.sdp,
              type: offer.type,
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const answer = await response.json();
          await pc.setRemoteDescription(new RTCSessionDescription(answer));

          elements.connectionStatus.textContent = "WebRTCå·²è¿æ¥";
          log("âœ… æœåŠ¡å™¨è¿æ¥æˆåŠŸï¼", "success");
        } catch (error) {
          log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, "error");
          elements.connectBtn.disabled = false;
          elements.systemStatus.textContent = "è¿æ¥å¤±è´¥";
          stats.errors++;
        }
      }

      // æ–­å¼€è¿æ¥
      async function disconnectFromServer() {
        try {
          log("æ­£åœ¨æ–­å¼€è¿æ¥...");

          // åœæ­¢éŸ³é¢‘å¯è§†åŒ–
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }

          // åœæ­¢æœ¬åœ°æµ
          if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
            localStream = null;
          }

          // å…³é—­PeerConnection
          if (pc) {
            pc.close();
            pc = null;
          }

          // å…³é—­WebSocket
          if (websocket) {
            websocket.close();
            websocket = null;
          }

          // é‡ç½®UIçŠ¶æ€
          elements.connectBtn.disabled = false;
          elements.disconnectBtn.disabled = true;
          elements.webrtcStatus.textContent = "æœªè¿æ¥";
          elements.webrtcStatus.className = "status-value";
          elements.audioStatus.textContent = "æœªæ¿€æ´»";
          elements.audioStatus.className = "status-value";
          elements.connectionStatus.textContent = "WebSocketå·²è¿æ¥";
          elements.systemStatus.textContent = "å·²æ–­å¼€";
          elements.latency.textContent = "-- ms";

          log("âœ… å·²æ–­å¼€è¿æ¥", "success");
        } catch (error) {
          log(`âŒ æ–­å¼€è¿æ¥æ—¶å‡ºé”™: ${error.message}`, "error");
        }
      }

      // åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–
      function initAudioVisualization() {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;

          const source = audioContext.createMediaStreamSource(localStream);
          source.connect(analyser);

          const bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);

          drawAudioVisualization();
          log("ğŸµ éŸ³é¢‘å¯è§†åŒ–å·²å¯åŠ¨");
        } catch (error) {
          log(`éŸ³é¢‘å¯è§†åŒ–åˆå§‹åŒ–å¤±è´¥: ${error.message}`, "warning");
        }
      }

      // ç»˜åˆ¶éŸ³é¢‘å¯è§†åŒ–
      function drawAudioVisualization() {
        if (!analyser || !dataArray) return;

        animationId = requestAnimationFrame(drawAudioVisualization);

        analyser.getByteFrequencyData(dataArray);

        const canvas = elements.audioCanvas;
        const canvasCtx = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / dataArray.length) * 2.5;
        let barHeight;
        let x = 0;

        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        elements.audioLevel.textContent = Math.round(average) + "%";

        for (let i = 0; i < dataArray.length; i++) {
          barHeight = (dataArray[i] / 255) * canvas.height;

          const gradient = canvasCtx.createLinearGradient(
            0,
            canvas.height - barHeight,
            0,
            canvas.height
          );
          gradient.addColorStop(0, "#4299e1");
          gradient.addColorStop(1, "#3182ce");

          canvasCtx.fillStyle = gradient;
          canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

          x += barWidth + 1;
        }
      }

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      function updateStats() {
        if (stats.startTime) {
          const uptime = Date.now() - stats.startTime;
          // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šç»Ÿè®¡ä¿¡æ¯çš„æ›´æ–°
        }
        setTimeout(updateStats, 1000);
      }

      // åˆå§‹åŒ–
      document.addEventListener("DOMContentLoaded", () => {
        log("é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–WebSocketè¿æ¥");
        initWebSocket();
        updateStats();
      });
    </script>
  </body>
</html>